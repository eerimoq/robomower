#!/usr/bin/env python

import argparse

from numpy import sin, arange, pi, zeros
from scipy.signal import lfilter, firwin

FILTER_TEST_I = """/* This file was generated by filter.py */

#define NUMBER_OF_INPUT_SAMPLES 80
#define NUMBER_OF_COEFFICIENTS {number_of_coefficients}
#define NUMBER_OF_OUTPUT_SAMPLES \\
    (NUMBER_OF_INPUT_SAMPLES - NUMBER_OF_COEFFICIENTS + 1)

struct filter_test_t {{
    const char *description;
    FAR const float *input;
    FAR const float *coefficients;
    FAR const float *ref_output;
}};

FAR static const float mower_input[NUMBER_OF_INPUT_SAMPLES] = {{
    /* sample 0-23 */
    1.0, 0.0, -1.0, 0.0, 1.0, -1.0, 1.0, -1.0,
    0.0, 1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 1.0,
    -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 0.0, -1.0,

    /* sample 24-47 */
    1.0, 0.0, -1.0, 0.0, 1.0, -1.0, 1.0, -1.0,
    0.0, 1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 1.0,
    -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 0.0, -1.0,

    /* sample 48-71 */
    1.0, 0.0, -1.0, 0.0, 1.0, -1.0, 1.0, -1.0,
    0.0, 1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 1.0,
    -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 0.0, -1.0,

    /* sample 72-79 */
    1.0, 0.0, -1.0, 0.0, 1.0, -1.0, 1.0, -1.0,
}};

FAR static const float mower_coefficients[NUMBER_OF_COEFFICIENTS] = {{
    1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0,
    -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0,
    -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0,
}};

FAR static const float mower_ref_output[NUMBER_OF_OUTPUT_SAMPLES] = {{
    /* sample 0-23 */
    16.0, -16.0, 0.0, 10.0, -8.0, -2.0, 8.0, -4.0,
    -4.0, 6.0, -2.0, 0.0, 2.0, -2.0, 0.0, 2.0,
    -6.0, 4.0, 4.0, -8.0, 2.0, 8.0, -10.0, 0.0,

    /* sample 24-47 */
    16.0, -16.0, 0.0, 10.0, -8.0, -2.0, 8.0, -4.0,
    -4.0, 6.0, -2.0, 0.0, 2.0, -2.0, 0.0, 2.0,
    -6.0, 4.0, 4.0, -8.0, 2.0, 8.0, -10.0, 0.0,

    /* sample 48-56 */
    16.0, -16.0, 0.0, 10.0, -8.0, -2.0, 8.0, -4.0,
    -4.0
}};

{data}

struct filter_test_t filter_test[] = {{
    {{
        .description = "test: mower",
        .input = mower_input,
        .coefficients = mower_coefficients,
        .ref_output = mower_ref_output
    }},
{tests}
    {{
        .description = NULL,
        .input = NULL,
        .coefficients = NULL,
        .ref_output = NULL
    }},
}};
"""

DATA = """
FAR static const float {name}_input[NUMBER_OF_INPUT_SAMPLES] = {{
{input}
}};

FAR static const float {name}_coefficients[NUMBER_OF_COEFFICIENTS] = {{
{coefficients}
}};

FAR static const float {name}_ref_output[NUMBER_OF_OUTPUT_SAMPLES] = {{
{ref_output}
}};
"""

TEST = """
    {{
        .description = "test: {description}",
        .input = {input},
        .coefficients = {coefficients},
        .ref_output = {ref_output}
    }},
"""


def as_c_array_elements(array):
    result = ""
    for i, v in enumerate(array):
        if i % 8 == 0:
            result += "    "
        else:
            result += " "
        result += "%f," % v
        if i % 8 == 7:
            result += "\n"
    return result


def create_signal(frequencies, amplitudes, number_of_samples, sample_rate):
    """Create a signal of given frequencies and their amplitudes.
    """
    timesamples = arange(number_of_samples) / sample_rate
    signal = zeros(len(timesamples))
    for frequency, amplitude in zip(frequencies, amplitudes):
        signal += amplitude * sin(2*pi*frequency*timesamples)
    return signal


def plot_signals(sample_rate, numtaps, signal, filtered_signal):
    from matplotlib.pylab import axes, plot, title, xlabel, show, figure, grid

    # The first N-1 samples are "corrupted" by the initial conditions
    warmup = numtaps - 1

    # The phase delay of the filtered signal
    delay = (warmup / 2) / sample_rate

    # Plot the signals
    figure(1)
    plot(t, signal)
    # Plot just the "good" part of the filtered signal.  The first N-1
    # samples are "corrupted" by the initial conditions.
    plot(t[warmup:]-delay, filtered_signal[warmup:], 'g', linewidth=4)
    grid(True)
    show()


def main(args):
    # Create a FIR filter
    sample_rate = 16000.0

    # The Nyquist rate of the signal.
    nyq_rate = sample_rate / 2.0

    # The cutoff frequency of the filter: 6KHz
    cutoff_hz = 6000.0

    # Length of the filter (number of coefficients, i.e. the filter order + 1)
    numtaps = 24

    # Use firwin to create a lowpass FIR filter
    coefficients = firwin(numtaps, cutoff_hz/nyq_rate)

    # create test data
    data = []
    tests = []

    frequencies = [10, 9000]
    amplitudes = [1.0, 0.2]
    number_of_samples = 80
    input_signal = create_signal(frequencies,
                                 amplitudes,
                                 number_of_samples,
                                 sample_rate)
    output_signal = lfilter(coefficients, 1.0, input_signal)[numtaps-1:]

    name = "low_pass_6000_hz"
    data.append(DATA.format(name=name,
                            input=as_c_array_elements(input_signal),
                            coefficients=as_c_array_elements(coefficients),
                            ref_output=as_c_array_elements(output_signal)))
    tests.append(TEST.format(description=name,
                             input=name + "_input",
                             coefficients=name + "_coefficients",
                             ref_output=name + "_ref_output"))

    data = "".join(data)
    tests = "".join(tests)

    with open("filter_test.i", "w") as fout:
        fout.write(FILTER_TEST_I.format(number_of_coefficients=numtaps,
                                        data=data,
                                        tests=tests))

    if args.plot:
        plot_signals(sample_rate, numtaps, signal, filtered_signal)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate FIR filter coefficients.")
    parser.add_argument('--plot', action="store_true", help="Plot the input and output signals.")
    args = parser.parse_args()
    main(args)
